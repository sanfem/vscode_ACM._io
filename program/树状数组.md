普通树状数组维护的信息及运算要满足 **结合律** 且 **可差分**，如加法（和）、乘法（积）、异或等。

- 结合律：(𝑥 ∘𝑦) ∘𝑧 =𝑥 ∘(𝑦 ∘𝑧)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "(x \circ y) \circ z = x \circ (y \circ z)")，其中 ∘![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\circ") 是一个二元运算符。
- 可差分：具有逆运算的运算，即已知 𝑥 ∘𝑦![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "x \circ y") 和 𝑥![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "x") 可以求出 𝑦![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "y")。
树状数组是线段树能解决问题的子集，树状数组可以完成的问题线段树一定可以完成。
树状数组用于解决单点修改和区间查询的问题
构建：
将一段前缀 [1,𝑛]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "[1, n]") 拆成 **不多于 𝐥𝐨𝐠⁡𝒏![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{\log n}") 段区间**，使得这 log⁡𝑛![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\log n") 段区间的信息是已知的。树状数组中，规定 𝑐[𝑥]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "c[x]") 管辖的区间长度为 2𝑘，运用lowbit进行计算上一个数组数据。
```cpp
int lowbit(int x) {  
 return x & -x
 }
```
区间查询：
```cpp
int getsum(int x) {  
  int ans = 0;
  while (x > 0) {
    ans = ans + c[x];
    x = x - lowbit(x);
  }
  return ans;
}
```
对于线状数组有三条性质：
性质 𝟏![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{1}")：对于 𝒙 ≤𝒚![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{x \le y}")，要么有 𝒄[𝒙]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[x]}") 和 𝒄[𝒚]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[y]}") 不交，要么有 𝒄[𝒙]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[x]}") 包含于 𝒄[𝒚]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[y]}")。
性质 𝟐![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{2}")：𝒄[𝒙]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[x]}") 真包含于 𝒄[𝒙 +𝐥𝐨𝐰𝐛𝐢𝐭⁡(𝒙)]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[x + \operatorname{lowbit}(x)]}")。
性质 3![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "3")：对于任意 𝒙 <𝒚 <𝒙 +𝐥𝐨𝐰𝐛𝐢𝐭⁡(𝒙)![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{x < y < x + \operatorname{lowbit}(x)}")，有 𝒄[𝒙]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[x]}") 和 𝒄[𝒚]![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7 "\boldsymbol{c[y]}") 不交。

单点修改：
```cpp
void add(int x, int k) {
  while (x <= n) {  
    c[x] = c[x] + k;
    x = x + lowbit(x);
  }
}
```
 
