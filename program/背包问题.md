概念：是一类经典的组合优化问题。
核心问题：有一个容量为 w 的背包和 n 个物品，每个物品有：
重量 w[i]  价值 v[i]

目标：选择物品放入背包，使得总重量不超过w且总价值最大。

主要类型：
1.0-1背包

- 每个物品要么完整放入，要么不放入
    
- 不能只放一部分

2 . 完全背包

- 每个物品可以无限次使用

3.多重背包

- 每个物品有数量限制 c[i]
    
- 可以转化为 0-1 背包或使用二进制优化

解决方法

- 动态规划：最常用，时间复杂度 O(n)
    
- 贪心算法：适用于分数背包
    
- 回溯法：小规模问题

例题：

（0-1背包）
#include<bits/stdc++.h>
using namespace std;
const int N = 1010;
int v1[N], w1[N];
int n, v;
int f[N][N];

int main()
{
    
    cin >> n >> v;
    for(int i = 1; i <= n; i++)
    cin >> v1[i] >> w1[i];
    
    for(int i = n; i >= 1; i--){
        for(int j = 0; j <= v; j++){
        if(j < v1[i]) f[i][j] = f[i + 1][j];
        
        else
        f[i][j] = max(f[i + 1][j - v1[i]] + w1[i], f[i + 1][j]);
        }
    }
    
    cout << f[1][v] << endl;
    return 0;
}