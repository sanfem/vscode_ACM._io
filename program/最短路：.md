1，Dijkstra算法，基于贪心，用于计算非负单源图的最佳算法，使用小根堆可以让复杂度降低为n(n**logm)
	1,初始化dist[1]=0,其余节点无限大
	 2，找到其余未标记的节点，或在优先对列中找出一个数
	 3，遍历所有出边执行松弛算法，对于优先队列，将符合条件的节点写入队列
```cpp
//[P4779 【模板】单源最短路径（标准版） - 洛谷](https://www.luogu.com.cn/problem/P4779)
#include<bits/stdc++.h>

using namespace std;

const int MAXN=2e5+1;

int dis[MAXN]={},vis[MAXN]={};

struct Node

{

    int x;

    int v;

    bool operator<(const Node &b) const {

         return v>b.v;

    }

};

vector<pair<int,int>> fp[MAXN]={};

priority_queue<Node> q;

int main(){

    ios::sync_with_stdio(false);

    cin.tie(0);

    cout.tie(0);

    int n,m,s;

    cin>>n>>m>>s;

    memset(dis,0x3f,sizeof(dis));

    dis[s]=0;

    vis[s]=1;

    for(int i=1;i<=m;i++){

        int x,y,v;

        cin>>x>>y>>v;

        fp[x].push_back({y,v});

    }

    q.push({s,0});

    while(!q.empty()){

        int z=q.top().x;

        int v=q.top().v;

        q.pop();

        for(pair<int,int> a:fp[z]){

            if(vis[a.first]==0&&dis[a.first]>a.second+dis[z]){

                dis[a.first]=a.second+dis[z];

                q.push({a.first,dis[a.first]});

            }

        }

        vis[z]=1;

    }

    for(int i=1;i<=n;i++){

        cout<<dis[i]<<" ";

    }

}
```
2，Bellman_Ford算法：基于迭代思想，
拓展，对于图中一条边(x,y,z),dist[y]<=dist[x]+z,则该边满足三角形不等式，可以证明，当数组dist下的所有边都满足三角形不等式时，该数组为所求求最短路数组。
所以，该算法思想是1，扫描所有边，执行松弛操作。2，重复上述操作，直到没有更新操作发生
我们可以知道，每一次循环操作都会让最短路径+1,而对于一个图来说最短路最短只有n-1条。因此当存在负环时，一旦循环超过n-1则说明存在负环。
当图是不联通图时，可以建立一个超级原点来链接所有节点
```cpp
[P3385 【模板】负环 - 洛谷](https://www.luogu.com.cn/problem/P3385)
#include<bits/stdc++.h>

using namespace std;

const int MAXN=2e3+1;

int dist[MAXN]={};

int cnt[MAXN]={},vis[MAXN]={};

void solve(int n ,int m,vector<pair<int,int>> a[]){

    queue<int> q;

    memset(cnt,0,sizeof(cnt));

    memset(vis,0,sizeof(vis));

    memset(dist,0x3f,sizeof(dist));

    dist[1]=0;

    q.push(1);

    vis[1]=1;

    while(!q.empty()){

        int x=q.front();

        q.pop();

        vis[x]=0;

        for(pair y:a[x]){

            if(dist[y.first]>dist[x]+y.second){

                dist[y.first]=dist[x]+y.second;

                cnt[y.first]=cnt[x]+1;

                if(cnt[y.first]>=n) {cout<<"YES"<<'\n';return;}

                if(vis[y.first]==0) {q.push(y.first);vis[y.first]=1;}

            }

        }

    }

    cout<<"NO"<<'\n';

}

int main(){

    ios::sync_with_stdio(false);

    cin.tie(0);

    cout.tie(0);

    int T;

    cin>>T;

    while(T--){

        vector<pair<int,int>> a[MAXN];

        int n,m;

        cin>>n>>m;

        for(int i=1;i<=m;i++){

            int x,y,v;

            cin>>x>>y>>v;

            if(v<0)a[x].push_back({y,v});

            else {a[x].push_back({y,v});a[y].push_back({x,v});}

        }

        solve(n,m,a);

    }

}
```
3，任意两点间最短路径：Floyd算法，时间复杂度：O(n3)
该算法基于动态规划的思想，类似于背包问题，转移方程为D[i,j]=min(D[i,j],D[i,k]+D[k,j]);
可以理解为将该问题分为两个子问题，经过编号不超过k-1的节点从i到j，或从i到k再到j。
```cpp

```
以上是三个主要的最短路算法，下面记录一些特殊方法：
分层图，对于有限的多条线路选择，我们可以建立多个图，在两个图中的每一个节点建立特殊边，再进行最短路运算 。（或者借助动态规划逻辑建图）；

闭合传包：基于Floryd算法，借助该算法的中间节点传导，来判断全图的关系。
```cpp
 Map[i][j]|=Map[k][j] & Map[i][k];//状态转移方程
```
 


