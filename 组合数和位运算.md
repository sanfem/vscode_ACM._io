1.组合数
组合数：C(n,m),含义是在每个物品中选出n个物品排列的方法数。与全排列A不同，组合数的排列不考虑顺序前后。有公式
```
$$
(a+b)^n=C(i,n)*a^i*b(n-i)
$$
```
关于组合数的快速计算有四种方法：
1.公式法：
```c++
long long C(int n,int m){
	if(m<n-m) m=n-m;
	long long ans=1;
	for(int i=m+1;i<=n;++i) ans*=i;
	for(int i=1;i<=n-m;++i) ans/=i;
	return ans;
}
```
 2.递推法（杨氏三角）：
 该方法可以与前缀和搭配
 ![[Pasted image 20250720163230.png]]
对于一个组合数，有C（n,m)=C(n-1,m)+C(n,m-1).
由此可得：
```cpp
void getc(){
for(int i=0;i<n;i++){
	for(int j=0;j<=i;j++){
	if(j==0)
	a[i][j]=1;
	else{
		a[i][j]=(a[i-1][j]+a[i-1][j-1]%mod;
		
	}
	}
}
}
```
 3.快速幂+乘法逆元
 ![[Pasted image 20250720163652.png]]
 乘法逆元：通过费马小定理可以得出
```cpp
  int qpow(long long a, int b)
{
   int ans = 1;
    a = (a % p + p) % p;
     for (; b; b >>= 1) 
     { 
     if (b & 1)  ans = (a * ans) % p;  a = (a * a) % p; } 
     return ans; 
}
```
 4.卢卡斯定理：
 有关卢卡斯定理的证明在[卢卡斯定理 - OI Wiki](https://oi-wiki.org/math/number-theory/lucas/)
/// 日后再补
 ```cpp
 #include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll t,n,m,mod;
ll apow(ll a,ll b,ll p){ 
	if(b==0) return 1;
	if(b==1) return a%p;
	ll x=apow(a,b/2,p)%p;
	if(b&1){
		return x*x%p*a%p;
	}
	return x*x%p;
}
ll c(ll a,ll b,ll p){
	if(b>a) return 0;
	ll res=1;
	for(int i=1,j=a;i<=b;i++,j--){ 
		res=(ll)res*j%p;
		res=(ll)res*apow(i,p-2,p)%p;
	}
	return res;
}
ll lucas(ll a,ll b,ll p){ 
	if(a<p&&b<p) return c(a,b,p)%p;
	return (ll)c(a%p,b%p,p)*lucas(a/p,b/p,p)%p;
}
signed main(){
	cin>>t;
	for(int i=1;i<=t;i++){
		cin>>n>>m>>mod;
		cout<<lucas(n+m,m,mod)<<'\n';
	}
  return 0; 
}
```